

# # This spec was generated by rspec-rails when you ran the scaffold generator.
# # It demonstrates how one might use RSpec to test the controller code that
# # was generated by Rails when you ran the scaffold generator.
# #
# # It assumes that the implementation code is generated by the rails scaffold
# # generator. If you are using any extension libraries to generate different
# # controller code, this generated spec may or may not pass.
# #
# # It only uses APIs available in rails and/or rspec-rails. There are a number
# # of tools you can use to make these specs even more expressive, but we're
# # sticking to rails and rspec-rails APIs to keep things simple and stable.

# RSpec.describe "/tweets", type: :request do
  
#   # This should return the minimal set of attributes required to create a valid
#   # Tweet. As you add validations to Tweet, be sure to
#   # adjust the attributes here as well.
#   let(:valid_attributes) {
#     skip("Add a hash of attributes valid for your model")
#   }

#   let(:invalid_attributes) {
#     skip("Add a hash of attributes invalid for your model")
#   }

#   describe "GET /index" do
#     it "renders a successful response" do
#       Tweet.create! valid_attributes
#       get tweets_url
#       expect(response).to be_successful
#     end
#   end

#   describe "GET /show" do
#     it "renders a successful response" do
#       tweet = Tweet.create! valid_attributes
#       get tweet_url(tweet)
#       expect(response).to be_successful
#     end
#   end

#   describe "GET /new" do
#     it "renders a successful response" do
#       get new_tweet_url
#       expect(response).to be_successful
#     end
#   end

#   describe "GET /edit" do
#     it "renders a successful response" do
#       tweet = Tweet.create! valid_attributes
#       get edit_tweet_url(tweet)
#       expect(response).to be_successful
#     end
#   end

#   describe "POST /create" do
#     context "with valid parameters" do
#       it "creates a new Tweet" do
#         expect {
#           post tweets_url, params: { tweet: valid_attributes }
#         }.to change(Tweet, :count).by(1)
#       end

#       it "redirects to the created tweet" do
#         post tweets_url, params: { tweet: valid_attributes }
#         expect(response).to redirect_to(tweet_url(Tweet.last))
#       end
#     end

#     context "with invalid parameters" do
#       it "does not create a new Tweet" do
#         expect {
#           post tweets_url, params: { tweet: invalid_attributes }
#         }.to change(Tweet, :count).by(0)
#       end

    
#       it "renders a response with 422 status (i.e. to display the 'new' template)" do
#         post tweets_url, params: { tweet: invalid_attributes }
#         expect(response).to have_http_status(:unprocessable_entity)
#       end
    
#     end
#   end

#   describe "PATCH /update" do
#     context "with valid parameters" do
#       let(:new_attributes) {
#         skip("Add a hash of attributes valid for your model")
#       }

#       it "updates the requested tweet" do
#         tweet = Tweet.create! valid_attributes
#         patch tweet_url(tweet), params: { tweet: new_attributes }
#         tweet.reload
#         skip("Add assertions for updated state")
#       end

#       it "redirects to the tweet" do
#         tweet = Tweet.create! valid_attributes
#         patch tweet_url(tweet), params: { tweet: new_attributes }
#         tweet.reload
#         expect(response).to redirect_to(tweet_url(tweet))
#       end
#     end

#     context "with invalid parameters" do
    
#       it "renders a response with 422 status (i.e. to display the 'edit' template)" do
#         tweet = Tweet.create! valid_attributes
#         patch tweet_url(tweet), params: { tweet: invalid_attributes }
#         expect(response).to have_http_status(:unprocessable_entity)
#       end
    
#     end
#   end

#   describe "DELETE /destroy" do
#     it "destroys the requested tweet" do
#       tweet = Tweet.create! valid_attributes
#       expect {
#         delete tweet_url(tweet)
#       }.to change(Tweet, :count).by(-1)
#     end

#     it "redirects to the tweets list" do
#       tweet = Tweet.create! valid_attributes
#       delete tweet_url(tweet)
#       expect(response).to redirect_to(tweets_url)
#     end
#   end
# end


require 'rails_helper'

RSpec.describe "users", type: :request do

    describe "POST /tweets" do
        let(:user) { create(:user) }
        let(:valid_params) { { tweet: { content: "This is a tweet.", user_id: user.id } } }
        let(:invalid_params) { { tweet: { content: "", user_id: user.id } } }

    # describe "Get /stats" do
    #     it "returns http success" do

    #     get stats_tweet_path(:tweet)

    #     expect(response.status).to eq(201)
    #     expect(response).to match_response1_schema("tweet")
    #     end
    # end

    
    # describe "Post /like" , post2: true do
    #     let(:user1){create(:user)} 
    #     let(:tweet1){create(:tweet, user: user1)}

    #     it "returns http success" do
    #     like1 = { tweet_id: tweet1.id, user_id: user1.id }
    #     p like1
            
    #     post "/tweets/:id/like",  params: { like: like1 }, as: :json

    #     expect(response.status).to eq(201)
    #     expect(response).to match_response_schema("like")
    #     end  
    # end 

    # describe "delete /dislike", dislike: true do
    #     let(:user1) { create(:user) }
    #     let(:tweet1) { create(:tweet, user: user1) }
      
    #     it "returns http success" do
    #       like1 = { tweet_id: tweet1.id, user_id: user1.id }
      
    #       # interpolación para reemplazar :id con el valor real de tweet1.id
    #       delete "/tweets/#{tweet1.id}/dislike", params: { like: like1 }, as: :json
      
    #       expect(response.status).to eq(201)
    #       expect(response).to match_response_schema("like")
    #     end
    #   end
      

    # describe "post /retweet" , post: true do 
    #     let(:user1){create(:user)}
    #     let(:tweet1){create(:tweet, user: user1)}
    #     it "returns http success" do 
          
    #         post "/tweets/:id/retweet",  params: { tweet: tweet1 }, as: :json

    #         expect(response.status).to eq(404)
    #         expect(response).to match_response_schema("tweet")
    #     end 
    # end 

#     describe "post /quote" do 
#         it "returns http success" do 
#             let(:user1){create(:user)}
#             let(:tweet1){create(:tweet, user: user1)}
#             post "/tweets/:id/quote", params: tweet1, as: :json

#             expect(response.status).to eq(201)
#             expect(response).to match_response_schema("tweet")
#         end 
#     end 
    
#     describe "post /reply" do 
#         it "returns http success" do 
#             let(:user1){create(:user)}
#             let(:tweet1){create(:tweet, user: user1)}
#             post "/tweets/:id/reply", params: tweet1, as: :json
#             expect(response.status).to eq(201)
#             expect(response).to match_response_schema("tweet")
#         end 
#     end 

#     describe "post /bookmark" do 
#         it "returns http success" do 
#             post bookmark_tweet_path(:bookmark)
            
#             expect(response.status).to eq(201)
#             expect(response).to match_response_schema("tweet")
#         end 
#     end 

#     describe "post /tweet" , tweet: true do 
#         let(:user1){create(:user)} 
#         let(:tweet1){create(:tweet, user: user1)}
#         it "returns http success" do 
           
#             p tweet1

#             post "/tweets", params: tweet1, as: :json

#             expect(response.status).to eq(201)
#             expect(response).to match_response_schema("tweet")
#         end 
#     end 

#     describe "get /tweet" , newtweet: true do
#         let(:user1){create(:user)} 
#         let(:tweet1){create(:tweet, user: user1)}

#         it "returns http success" do 

#             p tweet1

#             get "/tweets/new", params: tweet1, as: :json
#             expect(response.status).to eq(200)
#             expect(response).to match_response_schema("tweet")
#         end 
#     end 

#     describe "patch /tweet" do 
#         it "returns http success" do 
#             patch tweet_path(:tweet)

#             expect(response.status).to eq(201)
#             expect(response).to match_response_schema("tweet")
#         end 
#     end 

#     describe "put /tweet" do 
#         it "returns http success" do 
#             put tweet_path(:tweet)

#             expect(response.status).to eq(201)
#             expect(response).to match_response_schema("tweet")
#         end 
#     end 

# end 

# describe "POST /tweets/:id/like" , prueba: true do
#     let(:user) { create(:user) }
#     let(:tweet) { create(:tweet) } 

#     it "likes the tweet" do
#       post like_tweet_path(tweet.id), params: { user_id: user.id }

#       expect(response).to have_http_status(:ok)

#       expect(response).to match_response_schema("like")
#    end

    context "with valid params" do
    it 'returns 201 status response for creating a new tweet' do
      post api_tweets_path, :params => valid_params
      puts response.body

      expect(response).to have_http_status(:created)
    end
  end 
  
  context "with valid params" do
    it 'returns 201 status response for creating a new tweet' do
      post api_tweets_path, :params => valid_params
      puts response.body

      expect(response).to have_http_status(:created)
    end

    it "should create a new tweet matching json schema" do
      post api_tweets_path, params: valid_params
      puts response.body
      #Rails.logger.debug response.body
      
      expect(response).to match_response_schema("tweet")
    end
  end

  context "with invalid params" do
    it "does not create a new tweet" do
      post api_tweets_path, params: invalid_params
      puts response.body

      expect(response).to have_http_status(422)
    end
  end
end


describe "PUT /tweets/:id" do
  let(:original_tweet_content) { "Original content" }
  let(:updated_tweet_content) { "This is an updated tweet." }
  let(:empty_tweet_content) { "" }

  before do
    @tweet = create(:tweet, content: original_tweet_content)
  end

  context "with valid params" do
    it 'returns 200 status response for updating a tweet' do
      # La instancia se ha guardado con el contenido original
      expect(@tweet.content).to eq(original_tweet_content)
      puts @tweet.as_json

      # Actualizar el tweet
      put api_tweet_path(@tweet), params: { tweet: { content: updated_tweet_content } }

      # Recuperar el tweet de la base de datos y comprobar que ha sido actualizado
      @updated_tweet = Tweet.find(@tweet.id)
      puts @updated_tweet.as_json
      expect(@updated_tweet.content).to eq(updated_tweet_content)

      # Asegurar que la respuesta es la esperada
      expect(response).to have_http_status(:ok)
    end

    it "should update a tweet matching json schema" do
      put api_tweet_path(@tweet), params: { tweet: { content: updated_tweet_content } }

      expect(response).to match_response_schema("tweet")
    end
  end

  context "with invalid params" do
    it "does not update a tweet" do
      put api_tweet_path(@tweet), params: { tweet: { content: empty_tweet_content } }

      # Recuperar el tweet de la base de datos y comprobar que no ha sido actualizado
      @updated_tweet = Tweet.find(@tweet.id)
      expect(@updated_tweet.content).not_to eq(empty_tweet_content)

      # Asegurar que la respuesta es la esperada
      expect(response).to have_http_status(422)
    end
  end
end


describe "POST /tweets/:id/quote" do
  let!(:user) { create(:user) }
  let!(:tweet) { create(:tweet, user: user) }
  let!(:valid_quote_params) do 
    { 
      tweet: { 
        content: "This is a quoted tweet.", 
        original_tweet_id: tweet.id, 
        user_id: user.id 
      } 
    }
  end
  let!(:invalid_quote_params) do 
    { 
      tweet: { 
        content: "", 
        original_tweet_id: tweet.id, 
        user_id: user.id 
      } 
    }
  end

  context "with valid params" do
    it "returns 201 status response for creating a quote" do
      puts tweet.as_json
      post quote_api_tweet_path(tweet), params: valid_quote_params
      puts response.body
      
      expect(response).to have_http_status(:created)
    end

    it "should create a quote tweet matching json schema" do
      post quote_api_tweet_path(tweet), params: valid_quote_params
      expect(response).to match_response_schema("tweet")
    end
  end

  context "with invalid params" do
    it "does not create a quote tweet" do
      post quote_api_tweet_path(tweet), params: invalid_quote_params
      expect(response).to have_http_status(422)
    end
  end
end


describe "POST /tweets/:id/retweet" do
  let!(:user) { create(:user) } # Crea un usuario usando la fábrica
  let!(:tweet) { create(:tweet) } # Crea un tweet usando la fábrica

  context "with valid params" do
      it "returns 201 status response for creating a retweet" do
          puts tweet.as_json
          post retweet_api_tweet_path(tweet.id), params: { user_id: user.id }
          puts response.body

          expect(response).to have_http_status(:created)
      end

      it "should create a retweet matching json schema" do
          post retweet_api_tweet_path(tweet.id), params: { user_id: user.id }
          expect(response).to match_response_schema("tweet")
      end
  end

  context "with invalid params" do
      it "does not retweet again" do
          # Retweet once
          post retweet_api_tweet_path(tweet.id), params: { user_id: user.id }
          expect(response).to have_http_status(:created)

          # Try to retweet again
          post retweet_api_tweet_path(tweet.id), params: { user_id: user.id }
          expect(response).to have_http_status(422)
      end
  end
end


describe "POST /tweets/:id/like" do
  let(:user) { create(:user) }
  let(:tweet) { create(:tweet) } 

  it "likes the tweet" do
    post like_api_tweet_path(tweet.id), params: { user_id: user.id }

    expect(response).to have_http_status(:ok)

    expect(response).to match_response_schema("like")
  end

  context "when the user has already liked the tweet" do
      before do
          Like.create(user: user, tweet: tweet)
      end

      it "does not create another like" do
          post like_api_tweet_path(tweet.id), params: { user_id: user.id }

          expect(response).to have_http_status(422)
      end
  end
end


describe "DELETE /tweets/:id/unlike" do
  let!(:user) { create(:user) }
  let!(:tweet) { create(:tweet, user: user) }
  let!(:like) { create(:like, user: user, tweet: tweet) }  # Ensure the tweet is liked initially.

  context "when the tweet has been liked" do
      it "unlikes the tweet" do
        delete unlike_tweet_path(tweet.id)

        expect(response).to have_http_status(200)
      end
  end

  context "when the tweet hasn't been liked yet" do
      before do
          like.destroy  # Remove the like to mimic the scenario.
      end

      it "returns an error status" do
        delete unlike_tweet_path(tweet.id)

        expect(response).to have_http_status(:unprocessable_entity)
      end
  end
end


describe "POST /tweets/:id/bookmark" do
  let(:user) { create(:user) }
  let(:tweet) { create(:tweet) }

  context "when a user bookmarks a tweet" do
    it "bookmarks the tweet" do
      post bookmark_tweet_path(tweet.id, user_id: user.id)

      expect(response).to have_http_status(200)
      expect(response).to match_response_schema("bookmark")
    end

    context "when the tweet is already bookmarked by the user" do
      before do
        # Create an initial bookmark
        create(:bookmark, user: user, tweet: tweet)
      end

      it "does not bookmark the tweet again" do
        post bookmark_tweet_path(tweet.id, user_id: user.id)

        expect(response).to have_http_status(422)
        json_response = JSON.parse(response.body)
        expect(json_response["errors"]).to include("You've already bookmarked this tweet.")
      end
    end
  end
end


describe "DELETE /tweets/:id/unbookmark" do
  let(:user) { create(:user) }
  let(:tweet) { create(:tweet) }

  context "when the tweet has been bookmarked" do
    before do
      # Create an initial bookmark
      create(:bookmark, user: user, tweet: tweet)
    end

    it "unbookmarks the tweet" do
      delete unbookmark_tweet_path(tweet.id, user_id: user.id)

      expect(response).to have_http_status(200)
      json_response = JSON.parse(response.body)
      expect(json_response["message"]).to eq("Bookmark removed")
    end
  end

  context "when the tweet hasn't been bookmarked" do
    it "returns an error" do
      delete unbookmark_tweet_path(tweet.id, user_id: user.id)

      expect(response).to have_http_status(422)
      json_response = JSON.parse(response.body)
      expect(json_response["errors"]).to include("Bookmark not found.")
    end
  end
end
end
end 
end